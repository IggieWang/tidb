package core_test

import (
	"context"
	"testing"

	. "github.com/pingcap/check"
	"github.com/pingcap/tidb/domain"
	"github.com/pingcap/tidb/planner"
	"github.com/pingcap/tidb/planner/core"
	"github.com/pingcap/tidb/session"
	"github.com/pingcap/tidb/sessionctx"
	"github.com/pingcap/tidb/util/testkit"
	"github.com/pingcap/tidb/util/testleak"
)

func TestT(t *testing.T) {
	CustomVerboseFlag = true
	TestingT(t)
}

func (s *testAnalyzeSuite) TestTableInfoSets(c *C) {
	defer testleak.AfterTest(c)()
	store, dom, err := newStoreWithBootstrap()
	c.Assert(err, IsNil)
	testKit := testkit.NewTestKit(c, store)
	defer func() {
		dom.Close()
		store.Close()
	}()
	testKit.MustExec("use test")
	testKit.MustExec("drop table if exists t, t1")
	testKit.MustExec("create table t (id int, a int, b int, c int)")
	testKit.MustExec("create table t1 (id int, a int, b int, c int)")

	// This stats is generated by following format:
	// fill (a, b, c, e) as (i*100+j, i, i+j, i*100+j), i and j is dependent and range of this two are [0, 99].
	err = s.loadTableStats("analyzesSuiteTestIndexReadT.json", dom)
	c.Assert(err, IsNil)
	ctx := testKit.Se.(sessionctx.Context)
	sessionVars := ctx.GetSessionVars()
	sessionVars.HashAggFinalConcurrency = 1
	sessionVars.HashAggPartialConcurrency = 1
	tests := []struct {
		sql string
		num int
		eq  map[string]string
		o   map[string]string
		rg  map[string]string
		ref map[string]string
	}{
		{
			sql: "select t1.c,count(t1.a) from t t1 inner join t t2 on t1.c=t2.b where t1.b<t2.c group by t1.c,t2.c",
			num: 1,
			eq:  map[string]string{"t": "[]"},
			o:   map[string]string{"t": "[[c],[b],[a]]"},
			rg:  map[string]string{"t": "[b,c]"},
			ref: map[string]string{"t": "[c]"},
		},
		{
			sql: "select t.c,count(t.a) from t inner join t1 on t.c=t1.b where t.a=1 or t1.a=2 and t.b<t1.c group by t.c,t1.c",
			num: 2,
			eq:  map[string]string{"t": "[a]", "t1": "[a]"},
			o:   map[string]string{"t": "[[c],[a]]", "t1": "[[b],[c]]"},
			rg:  map[string]string{"t": "[b]", "t1": "[c]"},
			ref: map[string]string{"t": "[c]", "t1": "[]"},
		},
	}
	testKit.MustExec("set tidb_enable_index_advisor=1")
	for _, tt := range tests {
		stmts, err := session.Parse(ctx, tt.sql)
		c.Assert(err, IsNil)
		c.Assert(stmts, HasLen, 1)
		stmt := stmts[0]
		is := domain.GetDomain(ctx).InfoSchema()
		err = core.Preprocess(ctx, stmt, is)
		c.Assert(err, IsNil)
		finalPlan, err := planner.Optimize(context.TODO(), ctx, stmt, is)
		c.Assert(err, IsNil)
		p, err := core.GetPhysicalPlan(finalPlan)
		c.Assert(err, IsNil)
		q := core.NewQueryExprInfo(p)
		m := core.NewTableInfoSets(q)
		c.Assert(len(m), Equals, tt.num, Commentf("for %s", tt.sql))
		for name, tbl := range m {
			eq := "["
			for _, colName := range tbl.Eq {
				eq += colName.L + ","
			}
			if len(eq) != 1 {
				eq = eq[:len(eq)-1]
			}
			eq += "]"
			c.Assert(eq, Equals, tt.eq[name], Commentf("for %s", tt.sql))
			o := "["
			for _, colNames := range tbl.O {
				sub := "["
				for _, colName := range colNames {
					sub += colName.L + ","
				}
				if len(sub) != 1 {
					sub = sub[:len(sub)-1]
				}
				sub += "]"
				o += sub + ","
			}
			if len(o) != 1 {
				o = o[:len(o)-1]
			}
			o += "]"
			c.Assert(o, Equals, tt.o[name], Commentf("for %s", tt.sql))
			rg := "["
			for _, colName := range tbl.Rg {
				rg += colName.L + ","
			}
			if len(rg) != 1 {
				rg = rg[:len(rg)-1]
			}
			rg += "]"
			c.Assert(rg, Equals, tt.rg[name], Commentf("for %s", tt.sql))
			ref := "["
			for _, colName := range tbl.Ref {
				ref += colName.L + ","
			}
			if len(ref) != 1 {
				ref = ref[:len(ref)-1]
			}
			ref += "]"
			c.Assert(ref, Equals, tt.ref[name], Commentf("for %s", tt.sql))
		}
	}
}
