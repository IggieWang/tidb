package idxadvisor_test

import (
	"context"
	"fmt"

	. "github.com/pingcap/check"
	"github.com/pingcap/parser/model"
	"github.com/pingcap/tidb/domain"
	"github.com/pingcap/tidb/idxadvisor"
	"github.com/pingcap/tidb/planner"
	"github.com/pingcap/tidb/planner/core"
	"github.com/pingcap/tidb/session"
	"github.com/pingcap/tidb/sessionctx"
	"github.com/pingcap/tidb/util/testkit"
	"github.com/pingcap/tidb/util/testleak"
)

var _ = Suite(&testAnalyzeSuite{})

func (s *testAnalyzeSuite) TestFindIndices(c *C) {
	defer testleak.AfterTest(c)()
	store, dom, err := newStoreWithBootstrap()
	c.Assert(err, IsNil)
	testKit := testkit.NewTestKit(c, store)
	defer func() {
		dom.Close()
		store.Close()
	}()
	testKit.MustExec("use test")
	testKit.MustExec("drop table if exists t, t1")
	testKit.MustExec("create table t (id int, a int, b int, c int)")
	testKit.MustExec("create index b on t (b)")
	testKit.MustExec("create index b_c on t (b,c)")
	testKit.MustExec("create table t1 (a int, b int, index idx(a), index idxx(b))")

	// This stats is generated by following format:
	// fill (a, b, c, e) as (i*100+j, i, i+j, i*100+j), i and j is dependent and range of this two are [0, 99].
	err = s.loadTableStats("analyzesSuiteTestIndexReadT.json", dom)
	c.Assert(err, IsNil)
	ctx := testKit.Se.(sessionctx.Context)
	sessionVars := ctx.GetSessionVars()
	sessionVars.HashAggFinalConcurrency = 1
	sessionVars.HashAggPartialConcurrency = 1
	for i := 1; i < 8; i++ {
		testKit.MustExec(fmt.Sprintf("insert into t values(%v, %v, %v, %v)", i, i, 1, 1))
	}
	for i := 8; i < 16; i++ {
		testKit.MustExec(fmt.Sprintf("insert into t values(%v, %v, %v, %v)", i, i, 2, 2))
	}
	for i := 1; i < 16; i++ {
		testKit.MustExec(fmt.Sprintf("insert into t1 values(%v, %v)", i, i))
	}
	testKit.MustExec("analyze table t1")
	tests := []struct {
		sql   string
		index map[string]model.CIStr
	}{
		{
			sql:   "select count(*) from t group by b",
			index: map[string]model.CIStr{"t": model.NewCIStr("b")},
		},
		{
			sql:   "select c from t order by b",
			index: map[string]model.CIStr{"t": model.NewCIStr("b_c")},
		},
		{
			sql:   "select * from t, t1 where t.b = 1 and t1.a = 1",
			index: map[string]model.CIStr{"t": model.NewCIStr("b"), "t1": model.NewCIStr("idx")},
		},
	}
	testKit.MustExec("set tidb_enable_index_advisor=1")
	for _, tt := range tests {
		stmts, err := session.Parse(ctx, tt.sql)
		c.Assert(err, IsNil)
		c.Assert(stmts, HasLen, 1)
		stmt := stmts[0]
		is := domain.GetDomain(ctx).InfoSchema()
		err = core.Preprocess(ctx, stmt, is)
		c.Assert(err, IsNil)
		finalPlan, err := planner.Optimize(context.TODO(), ctx, stmt, is)
		c.Assert(err, IsNil)
		p, err := core.GetPhysicalPlan(finalPlan)
		c.Assert(err, IsNil)
		indices := idxadvisor.FindVirtualIndices(p)
		for _, idx := range indices {
			c.Assert(idx.Index.Name, DeepEquals, tt.index[idx.Table.Name.L], Commentf("for %s", tt.sql))
		}
	}
}
